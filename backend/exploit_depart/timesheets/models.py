from datetime import date, datetime

from django.db import models
from employees.models import Employee

from .choices import DAY_STATUS, shortened, sickday, vacation, weekend, workday
from .services.timesheet_manager import add_workdays

Q = models.Q
F = models.F


class WorkDay(models.Model):
    class Meta:
        constraints = [
            # Employee must not have several workdays with the same date
            models.UniqueConstraint(fields=["date", "employee"], name="unique_workday"),
            # Checks if user populated both launch fields (both NULL OR both with times)
            models.CheckConstraint(
                check=(Q(launch_started__isnull=False) & Q(launch_ended__isnull=False))
                | (Q(launch_started__isnull=True) & Q(launch_ended__isnull=True)),
                name="launch_data_integrity",
                violation_error_message="Не указано время начала или окончания обеденного перерыва.",
            ),
            # Checks if user populated both work fields (both NULL OR both with times)
            models.CheckConstraint(
                check=(Q(work_started__isnull=False) & Q(work_ended__isnull=False))
                | (Q(work_started__isnull=True) & Q(work_ended__isnull=True)),
                name="work_data_integrity",
                violation_error_message="Не указано время начала или окончания рабочего дня.",
            ),
            # If there is launch then work needs to be too (no launch without work)
            models.CheckConstraint(
                check=(Q(launch_started__isnull=False) & Q(work_started__isnull=False))
                | Q(launch_started__isnull=True),
                name="if_launch_then_work",
                violation_error_message="Если указывается время начала и окончания обеденного перерыва, "
                "то время начала и окончания рабочего дня также должно быть указано.",
            ),
            # Checks if launch fields populated properly (both NULL OR (start time BEFORE end time))
            models.CheckConstraint(
                check=Q(launch_started__isnull=True)
                | Q(launch_started__lt=F("launch_ended")),
                name="launch_start_before_end",
                violation_error_message="Неправильно указано время начала и окончания обеденного перерыва.",
            ),
            # Checks if work fields populated properly (both NULL OR (start time BEFORE end time))
            models.CheckConstraint(
                check=Q(work_started__isnull=True)
                | Q(work_started__lt=F("work_ended")),
                name="work_start_before_end",
                violation_error_message="Неправильно указано время начала и окончания рабочего дня.",
            ),
            # Checks if it's weekend/sickday/vacation or workday with launch
            # (NO work AND NO launch) OR (work_start < launch_start < launch_end < work_end)
            models.CheckConstraint(
                check=(
                    Q(launch_started__isnull=True)
                    & Q(work_started__isnull=True)
                    & Q(day_status__in=[weekend, sickday, vacation])
                )
                | (
                    Q(work_started__lt=F("launch_started"))
                    & Q(work_ended__gt=F("launch_ended"))
                    & Q(day_status__in=[workday, shortened])
                ),
                name="weekend_or_launch_in_work_period",
                violation_error_message="Для выходного/больничного/отпуска время начала и окончания обеденного "
                "перерыва и время начала и окончания рабочего дня не указывается. "
                "Также обеденный перерыв должен проходить в течение рабочего дня "
                "(Начало рабочего дня < Начало обеденного перерыва "
                "< Конец обеденного перерыва < Конец рабочего дня).",
            ),
        ]

    date = models.DateField(verbose_name="Дата", null=False, blank=False)
    employee = models.ForeignKey(
        to=Employee,
        related_name="work_days",
        on_delete=models.CASCADE,
        verbose_name="Работник",
        null=False,
        blank=False,
    )
    day_status = models.CharField(
        max_length=255,
        choices=DAY_STATUS,
        verbose_name="Учёт в табеле",
        null=False,
        blank=False,
    )
    work_started = models.TimeField(
        verbose_name="Начало рабочего дня", null=True, blank=True
    )
    work_ended = models.TimeField(
        verbose_name="Конец рабочего дня", null=True, blank=True
    )
    launch_started = models.TimeField(
        verbose_name="Начало обеденного перерыва", null=True, blank=True
    )
    launch_ended = models.TimeField(
        verbose_name="Конец обеденного перерыва", null=True, blank=True
    )
    launch_duration = models.DurationField(
        verbose_name="Длительность обеденного перерыва", null=True, blank=True
    )
    work_duration = models.DurationField(
        verbose_name="Длительность рабочего времени (с учётом обеденного перерыва)",
        null=True,
        blank=True,
    )

    @staticmethod
    def _calculate_timedelta(start_time, end_time):
        return datetime.combine(date.min, end_time) - datetime.combine(
            date.min, start_time
        )

    def save(self, *args, **kwargs):
        self.full_clean()

        # Automatic population of work_duration and launch_duration fields
        if self.work_started is None:
            self.work_duration = None
            self.launch_duration = None
        else:
            self.work_duration = self._calculate_timedelta(
                self.work_started, self.work_ended
            )
            if self.launch_started is None:
                self.launch_duration = None
            else:
                self.launch_duration = self._calculate_timedelta(
                    self.launch_started, self.launch_ended
                )
                self.work_duration -= self.launch_duration
        super().save(*args, **kwargs)


class TimeSheet(models.Model):
    timesheet_name = models.CharField(
        max_length=255, unique=True, null=False, blank=False
    )
    employees = models.ManyToManyField(
        to=Employee,
        related_name="timesheets",
        verbose_name="Работник",
        blank=False,
    )
    work_days = models.ManyToManyField(
        to=WorkDay,
        related_name="timesheets",
        verbose_name="Календарные дни",
        blank=True,
    )
    period_start = models.DateField(
        verbose_name="Начало учётного периода", null=False, blank=False
    )
    period_end = models.DateField(
        verbose_name="Конец учётного периода", null=False, blank=False
    )

    def save(self, *args, **kwargs):
        super().save(*args, **kwargs)
        add_workdays(self)
