from datetime import timedelta

from rest_framework.exceptions import ValidationError

from common.data.timesheets import choices
from common.data.timesheets.validation import messages
from common.serialization.validation.mixins import ValidatorMixin
from common.services.utils import calculate_timedelta


class WorkDayValidator(ValidatorMixin):
    def workday_object_validation(self):
        day_status = self.get_from_dict_or_db("day_status")
        work_started = self.get_from_dict_or_db("work_started")
        work_ended = self.get_from_dict_or_db("work_ended")
        launch_started = self.get_from_dict_or_db("launch_started")
        launch_ended = self.get_from_dict_or_db("launch_ended")
        duty_duration = self.get_from_dict_or_db("duty_duration")

        return self._perform_validation(
            day_status,
            work_started,
            work_ended,
            launch_started,
            launch_ended,
            duty_duration,
        )

    def multiple_workday_object_validation(self):
        def _get_data_or_message(field_name, message_name):
            nonlocal raise_exc_flag
            try:
                return self.data[field_name]
            except KeyError:
                self.error_dict["messages"].append(messages.get(message_name))
                raise_exc_flag = True

        self.error_dict = self.get_default_error_dict()
        raise_exc_flag = False

        day_status = self.data["day_status"]
        work_started = _get_data_or_message("work_started", "work_started_not_filled")
        work_ended = _get_data_or_message("work_ended", "work_ended_not_filled")
        launch_started = _get_data_or_message(
            "launch_started", "launch_started_not_filled"
        )
        launch_ended = _get_data_or_message("launch_ended", "launch_ended_not_filled")
        duty_duration = self.data.get("duty_duration")

        if raise_exc_flag:
            raise ValidationError(detail=self.error_dict)

        return self._perform_validation(
            day_status,
            work_started,
            work_ended,
            launch_started,
            launch_ended,
            duty_duration,
        )

    def _clean_data(self, duty_duration):
        zero_day = timedelta(0)
        full_day = timedelta(days=1)

        if duty_duration == zero_day:
            self.data["duty_duration"] = None

        if duty_duration and duty_duration > full_day:
            self.data["duty_duration"] = full_day

    def _perform_validation(
        self,
        day_status,
        work_started,
        work_ended,
        launch_started,
        launch_ended,
        duty_duration,
    ):
        self.error_dict = self.get_default_error_dict()

        self._clean_data(duty_duration)

        # Check if weekend/sickday/vacation filled properly
        if day_status in [
            choices.weekend,
            choices.sickday,
            choices.vacation,
        ]:
            values = [work_started, work_ended, launch_started, launch_ended]
            if any(values):
                self.error_dict["messages"] = [
                    messages.get("if_weekend_filled_properly")
                ]
                raise ValidationError(detail=self.error_dict)

            if duty_duration and day_status in [choices.sickday, choices.vacation]:
                self.error_dict["messages"] = [
                    messages.get("duty_on_vacation_or_sickday")
                ]
                raise ValidationError(detail=self.error_dict)

            return self.data

        # Check if workday/weekend_work/shortened filled properly
        work_data = [work_started, work_ended]

        if not all(work_data):
            self.error_dict["messages"] = [messages.get("work_data_integrity")]
            raise ValidationError(detail=self.error_dict)

        if not work_started < work_ended:
            self.error_dict["messages"] = [messages.get("work_start_before_end")]
            raise ValidationError(detail=self.error_dict)

        launch_data = [launch_started, launch_ended]

        if all(launch_data):
            if not work_started < launch_started < launch_ended < work_ended:
                self.error_dict["messages"] = [messages.get("launch_in_work_period")]
                raise ValidationError(detail=self.error_dict)

        elif any(launch_data):
            self.error_dict["messages"] = [messages.get("launch_data_integrity")]
            raise ValidationError(detail=self.error_dict)

        # Check if duty_duration filled properly
        if duty_duration > timedelta(days=1) - calculate_timedelta(
            work_started, work_ended
        ):
            self.error_dict["messages"] = [messages.get("duty_data_integrity")]
            raise ValidationError(detail=self.error_dict)

        return self.data
