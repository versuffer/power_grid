from django.shortcuts import reverse

import pytest
from rest_framework import status
from testing.tests.utils.mixins import TestUtilsMixin, TestValidationMixin

from common.data.timesheets import choices
from common.exceptions.handlers import custom_exception_handler
from timesheets.workdays.models import WorkDay


@pytest.mark.django_db
class TestWorkdaysValidation(TestValidationMixin, TestUtilsMixin):
    model_class = WorkDay
    base_url_name = "workday"

    @pytest.mark.parametrize(
        "data",
        [
            {"work_started": None},
            {"work_ended": None},
            {"work_started": None, "work_ended": None},
        ],
    )
    def test_validation_work_data_integrity(self, workday_saved, auth_client, data):
        json_data = self.to_json(data)

        # Getting original exception instance
        val_err_exc = self.get_val_err_exc(message_key="work_data_integrity")

        response = auth_client.patch(
            self.detail_url(pk=workday_saved.id),
            content_type="application/json",
            data=json_data,
        )

        assert response.status_code == status.HTTP_400_BAD_REQUEST
        assert (
            response.data == custom_exception_handler(exc=val_err_exc, context={}).data
        )

    @pytest.mark.parametrize("data", [{"launch_started": None}, {"launch_ended": None}])
    def test_validation_launch_data_integrity(self, workday_saved, auth_client, data):
        json_data = self.to_json(data)

        # Getting original exception instance
        val_err_exc = self.get_val_err_exc(message_key="launch_data_integrity")

        response = auth_client.patch(
            self.detail_url(pk=workday_saved.id),
            content_type="application/json",
            data=json_data,
        )

        assert response.status_code == status.HTTP_400_BAD_REQUEST
        assert (
            response.data == custom_exception_handler(exc=val_err_exc, context={}).data
        )

    @pytest.mark.parametrize(
        "data",
        [
            {"work_started": choices.default_workday_start},
            {"work_ended": choices.default_workday_end},
            {"launch_started": choices.default_launch_start},
            {"launch_ended": choices.default_launch_end},
            {
                "day_status": choices.sickday,
                "work_started": choices.default_workday_start,
            },
            {"day_status": choices.sickday, "work_ended": choices.default_workday_end},
            {
                "day_status": choices.sickday,
                "launch_started": choices.default_launch_start,
            },
            {"day_status": choices.sickday, "launch_ended": choices.default_launch_end},
            {
                "day_status": choices.vacation,
                "work_started": choices.default_workday_start,
            },
            {"day_status": choices.vacation, "work_ended": choices.default_workday_end},
            {
                "day_status": choices.vacation,
                "launch_started": choices.default_launch_start,
            },
            {
                "day_status": choices.vacation,
                "launch_ended": choices.default_launch_end,
            },
        ],
    )
    def test_validation_if_weekend_filled_properly(
        self, weekend_saved, auth_client, data
    ):
        json_data = self.to_json(data)

        # Getting original exception instance
        val_err_exc = self.get_val_err_exc(message_key="if_weekend_filled_properly")

        response = auth_client.patch(
            self.detail_url(pk=weekend_saved.id),
            content_type="application/json",
            data=json_data,
        )

        assert response.status_code == status.HTTP_400_BAD_REQUEST
        assert (
            response.data == custom_exception_handler(exc=val_err_exc, context={}).data
        )

    @pytest.mark.parametrize(
        "data",
        [
            {"work_started": "13:00", "work_ended": "12:00"},
            {"work_started": "12:00", "work_ended": "12:00"},
        ],
    )
    def test_validation_work_start_before_end(self, workday_saved, auth_client, data):
        json_data = self.to_json(data)

        # Getting original exception instance
        val_err_exc = self.get_val_err_exc(message_key="work_start_before_end")

        response = auth_client.patch(
            self.detail_url(pk=workday_saved.id),
            content_type="application/json",
            data=json_data,
        )

        assert response.status_code == status.HTTP_400_BAD_REQUEST
        assert (
            response.data == custom_exception_handler(exc=val_err_exc, context={}).data
        )

    @pytest.mark.parametrize(
        "data",
        [
            {"launch_started": "13:00", "launch_ended": "12:00"},
            {
                "work_started": "8:00",
                "work_ended": "14:00",
                "launch_started": "13:00",
                "launch_ended": "15:00",
            },
            {
                "work_started": "8:00",
                "work_ended": "14:00",
                "launch_started": "14:00",
                "launch_ended": "15:00",
            },
            {
                "work_started": "8:00",
                "work_ended": "14:00",
                "launch_started": "15:00",
                "launch_ended": "16:00",
            },
            {
                "work_started": "8:00",
                "work_ended": "14:00",
                "launch_started": "6:00",
                "launch_ended": "7:00",
            },
            {
                "work_started": "8:00",
                "work_ended": "14:00",
                "launch_started": "7:00",
                "launch_ended": "8:00",
            },
        ],
    )
    def test_validation_launch_in_work_period(self, workday_saved, auth_client, data):
        json_data = self.to_json(data)

        # Getting original exception instance
        val_err_exc = self.get_val_err_exc(message_key="launch_in_work_period")

        response = auth_client.patch(
            self.detail_url(pk=workday_saved.id),
            content_type="application/json",
            data=json_data,
        )

        assert response.status_code == status.HTTP_400_BAD_REQUEST
        assert (
            response.data == custom_exception_handler(exc=val_err_exc, context={}).data
        )

    # def test_multiple_update_validation_1(self, multiple_update_weekend_data, auth_client):
    #     data = multiple_update_weekend_data.copy()
    #     del data["day_status"]
    #     json_data = self.to_json(data)
    #
    #     # Getting original exception instance
    #     val_err_exc = self.get_val_err_exc(message_key="day_status_not_filled")
    #
    #     response = auth_client.patch(
    #         reverse("timesheet-list") + "workdays/update/",
    #         content_type="application/json",
    #         data=json_data,
    #     )
    #
    #     assert response.status_code == status.HTTP_400_BAD_REQUEST
    #     assert (
    #             response.data == custom_exception_handler(exc=val_err_exc, context={}).data
    #     )
    #
    # def test_multiple_update_validation_6(self, auth_client):
    #     data = {"pk_list": []}
    #     json_data = self.to_json(data)
    #
    #     # Getting original exception instance
    #     val_err_exc = self.get_mult_val_err_exc(
    #         message_keys=[
    #             "day_status_not_filled",
    #             "work_started_not_filled",
    #             "work_ended_not_filled",
    #             "launch_started_not_filled",
    #             "launch_ended_not_filled",
    #         ]
    #     )
    #
    #     response = auth_client.patch(
    #         reverse("timesheet-list") + "workdays/update/",
    #         content_type="application/json",
    #         data=json_data,
    #     )
    #
    #     assert response.status_code == status.HTTP_400_BAD_REQUEST
    #     assert (
    #             response.data == custom_exception_handler(exc=val_err_exc, context={}).data
    #     )
